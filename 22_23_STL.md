# Standard Template Library
***
## Giới thiệu
***
Standard Template Library ( STL) là một tập hợp các thư viện thiết kế để hỗ trợ lập trình tổng quát (generic programming). 

STL C++ cung cấp một tập hợp các template classes và functions để thực hiện nhiều loại cấu trúc dữ liệu và các thuật toán phổ biến. 

1 số cấu trúc dữ liệu như ngăn xếp stack, hàng đợi queue, ở C không có thư viện nên mình phải tự triển khai ns nhưng C++ thì mình có thể tự triển khai bằng class và template. Tuy nhiên ở C++ có thiết kế sẵn thư viện để người dùng
	
STL đã trở thành một phần quan trọng của ngôn ngữ C++ và làm cho việc lập trình trở nên mạnh mẽ, linh hoạt và hiệu quả.

Một số thành phần chính của STL:
- Containers (Cấu trúc dữ liệu) : (vector, … slide 2 ghi rõ )
- Iterators (Bộ lặp)
- Algorithms (Thuật toán)
- Functors & Lambda
***
## Container
***
Một container là một cấu trúc dữ liệu chứa nhiều phần tử theo một cách cụ thể. STL (Standard Template Library) cung cấp một số container tiêu biểu giúp lưu trữ và quản lý dữ liệu. 

Một vài containers phổ biến:
- Vector (mảng + template)
- List 
- Map (JSON)
- Array 
- stack, queue
***
## Phần 1: Vector
***
### 1.1.	Đặc điểm 
***
Vector là 1 trong những container quqan trọng nhất trong STL của C++. Nó cung cấp 1 mảng động với khả năng thay đổi kích thước 1 cách linh hoạt 

- std::vector là là một mảng động (dynamic array) trong C++. Nó tự động quản lý bộ nhớ, có thể tăng kích thước khi thêm phần tử mới, và cho phép truy cập ngẫu nhiên như mảng thông thường.
- Truy cập ngẫu nhiên: Việc truy cập các phần tử của vector có thể được thực hiện bằng cách sử dụng chỉ số
- Hiệu suất chèn và xóa; chèn và xóa phần tử ở cuối vector có hiệu suất tốt. Tuy nhiên chèn và xóa ở vị trí bất kỳ có thể đòi hỏi di chuyển 1 số phần tử
Vector thực chất là 1 mảng đưuọc cấp phát động kết hợp template để tạo thành thư viện

### 1.2.	Cú pháp khai báo
***
Vector được thiest kế dưới dạng 1 class (thay vì là 1 mảng động) vì class mới có thể có các hàm bên trong để sử dụng 

Cú pháp khai báo:
```cpp
// cách 0
vector<data_type> name;  // vector rỗng
// cách 1
vector<data_type> name(size);  // size là số lượng phần tử khởi tạo và giá trị khởi tạo mặc định là 0
// cách 2
vector<data_type> name(size, value);  // value: giá trị khởi tạo cho các phần tử
// cách 3
vector<data_type> name = {1, 2, 3, 4, 5};
```
#### Ví dụ 1: Khai báo cách 1
ở đay vec như là 1 đối tượng vậy vì vector vốn là 1 class 
```cpp
int main(int argc, char const *argv[])
{
    vector<int> vec(5); // cách 2: 5 phần tử -> 20 bytes
    
    return 0;
}
```
Khi khởi tạo thì ban đầu giá trị mặc định là 0
```cpp
int main(int argc, char const *argv[])
{
    vector<int> vec(5); // cách 2
    for(int i= 0; i<5; i++)
    {
        cout << vec[i] << " ";
    }
    return 0;
}
```
Kết quả
```cpp
0 0 0 0 0
```
#### Ví dụ 2: Khai báo cách 2

```cpp
int main(int argc, char const *argv[])
{
    // vector<int> vec(5); // cách 2
    vector<int> vec(5, 2); // cách 3
    for(int i= 0; i<5; i++)
    {
        cout << vec[i] << " ";
    }
    return 0;
}
```
Kết quả 
```cpp
2 2 2 2 2 
```
#### Ví dụ 3: Khai báo cách 3
Với những cách trên thì có nhược điểm là các phần tử khai báo đều có giá trị là như nhau
```cpp
int main(int argc, char const *argv[])
{
    // vector<int> vec(5); // cách 1
    // vector<int> vec(5, 2); // cách 2
    vector<int> vec = {1,2,3,4,5};  // cách 3

    vec.at(0) = 20;
    vec.at(2) = 50;

    // for(int i= 0; i<5; i++)
    for(int i= 0; i<vec.size(); i++)
    {
        cout << vec[i] << " ";   // or vec.at(i)
    }
    return 0;
}
```
kết quả 
```cpp
20 2 50 4 5
```
***
### 1.3. Phương thức của vector
***
#### 1.3.1. Một số method của vector
***
| Method | Chức năng |
| -----| -----|
| at()	| truy cập để đọc hoặc thay đổi giá trị phần tử của vector. (đọc và ghi) |
| size()	| trả về kích thước của vector. |
| resize()	| thay đổi kích thước của vector. |
| begin()	| Trả về một **iterator** trỏ đến địa chỉ phần tử **đầu tiên** của vector. |
| end()	| Trả về một iterator trỏ đến địa chỉ **sau phần tử cuối cùng** của vector. |

##### Ví dụ 1: hàm size() và at()
```cpp
int main(int argc, char const *argv[])
{
    // vector<int> vec(5); // cách 2
    vector<int> vec(5, 2); // cách 3

    vec.at(0) = 20;
    vec.at(2) = 50;

    // for(int i= 0; i<5; i++)
    for(int i= 0; i<vec.size(); i++)
    {
        cout << vec[i] << " ";   // or vec.at(i)
    }
    return 0;
}
```
##### Ví dụ 2: hàm resize()
```cpp
int main(int argc, char const *argv[])
{
    // vector<int> vec(5); // cách 1
    // vector<int> vec(5, 2); // cách 2
    vector<int> vec = {1,2,3,4,5};  // cách 3

    vec.at(0) = 20;
    vec.at(2) = 50;

    vec.resize(7);      // giống realloc ở C

    // for(int i= 0; i<5; i++)
    for(int i= 0; i<vec.size(); i++)
    {
        cout << vec[i] << " ";   // or vec.at(i)
    }
    return 0;
}
```
Kết quả
```cpp
20 2 50 4 5 0 0
```
#### 1.3.2. Duyệt vector
***
có 3 cách duyệt vector
```cpp
// cách 1: for thông thường
for (int i = 0; i < v.size(); ++i)      // cách thông thường
    cout << v[i] << " ";
// cách 2: for cải tiến
for (int x : v)   // for cải tiến - C++11
    cout << x << " ";
// cách 3: Iterator
for (auto it = v.begin(); it != v.end(); ++it)
    cout << *it << " ";
```
##### Ví dụ 1: for cải tiến
```cpp
int main(int argc, char const *argv[])
{
    vector<int> vec = {1,2,3,4,5};  // cách 3

    vec.at(0) = 20;
    vec.at(2) = 50;

    vec.resize(7);      // giống realloc ở C

    for(int i= 0; i<vec.size(); i++)
    {
        cout << vec[i] << " ";   // or vec.at(i)
    }

    cout << endl;
    for(int i : vec)
    {
        // cout << vec.at(i) << " ";   
        // lỗi terminate called after throwing an instance of 'std::out_of_range'
        // what():  vector::_M_range_check: __n (which is 20) >= this->size() (which is 7)
        cout << i << " "; 
    }

    return 0;
}
```
Lúc này i không còn là chỉ số nữa, i bây h khi duyệt qua thì i sẽ đóng vai trò như là giá trị của phần tử đó luôn

Kết quả
```cpp
20 2 50 4 5 0 0 
20 2 50 4 5 0 0
```

##### Ví dụ 2: hàm begin() và hàm end()
```cpp
/*
    1: 0x01 0x02 0x03 0x04 
    2:
    ...
    5: 0xa1 0xa2 0xa3 0xa4      0xa5
*/
```
Hàm begin sẽ đọc được địa chỉ của phần tử 1 (từ 0x01 đến 0x04) và trả về giá trị địa chỉ đầu tiên trong đó là 0x01
Còn hàm end sẽ trả về địa chỉ sau phần tử cuối cùng tức là 0xa5.
=> Cả begin và en đều trả về các giá trị iterator
=> Nôm na thì iterator là những con trỏ nên mình cần phải truyền vào địa chỉ và mình cần duyệt qua đại chỉ bắt đầu và đại chỉ kết thúc

```cpp
int main(int argc, char const *argv[])
{
    vector<int> vec = {1,2,3,4,5};  // cách 3

    vec.at(0) = 20;
    vec.at(2) = 50;

    vec.resize(7);      // giống realloc ở C

    // for(int i= 0; i<5; i++)
    for(int i= 0; i<vec.size(); i++)
    {
        cout << vec[i] << " ";   // or vec.at(i)
    }

    cout << endl;
    for(int i : vec)      // for cải tiến 
    {
        cout << i << " "; 
    }

    cout << endl;

    // for cách 3
    vector<int> :: iterator it;     // khai báo đối tượng dùng class iterator
    for(auto it = vec.begin(); it != vec.end(); it++)
    {
        cout << *it << " ";        // dải tham chiếu
    }

    return 0;
}
```

Kết quả
```cpp
20 2 50 4 5 0 0 
20 2 50 4 5 0 0
20 2 50 4 5 0 0
```

#### 1.3.3.	Một số method liên quan đến thêm/xóa phần tử của vector:
***
| Method | Chức năng |
| ---- | ---- |
| push_back()	| thêm phần tử vào vị trí cuối của vector. |
| pop_back()	| xóa phần tử ở vị trí cuối của vector. |
| insert()	| thêm phần tử vào vị trí bất kỳ. |
| erase()	| xóa phần tử ở vị trí bất kỳ hoặc xóa các phần tử trong phạm vi được chỉ định. |
| clear()	| xóa toàn bộ phần tử của vector. |

=> Không có các hàm tác động đến front 

##### Ví dụ 1: hàm push_back()
khi khai báo 1 vector rỗng thì không có giá trị nao trong đó cả và ta phải dùng các hàm push, pop, insert,... để thêm phần tử vào (mà còn không có hàm dành cho front nữa ) nhưng như thế thì nó khong liên kết chung vs nhau
```cpp
int main(int argc, char const *argv[])
{
    vector<int> vec;    // khai báo vector rỗng
    vec.push_back(1);   // 1
    vec.push_back(2);   // 1 2
    vec.push_back(3);   // 1 2 3 
    vec.push_back(4);   // 1 2 3 4 
    vec.push_back(5);   // 1 2 3 4 5

    for(int i= 0; i<vec.size(); i++)
    {
        cout << vec[i] << " ";   // or vec.at(i)
    }
    
    return 0;
}
```
Kết quả
```cpp
1 2 3 4 5 
```

##### Ví dụ 2: hàm insert()
hàm insert ở trong vector khác với insert trong single linked list, rằng ở đây là truyền vào địa chỉ chứ không phải là vị trí 

```cpp
int main(int argc, char const *argv[])
{
    vector<int> vec;    // khai báo vector rỗng
    vec.push_back(1);   // 1
    vec.push_back(2);   // 1 2
    vec.push_back(3);   // 1 2 3 
    vec.push_back(4);   // 1 2 3 4 
    vec.push_back(5);   // 1 2 3 4 5

    // vec.insert(0, 10);  // lỗi no matching
    vec.insert(vec.begin(), 10);        // push_front()
    vec.insert(vec.end(), 30);      // push_back()


    for(int i= 0; i<vec.size(); i++)
    {
        cout << vec[i] << " ";   // or vec.at(i)
    }

    return 0;
}
```
Kết quả
```cpp
10 1 2 3 4 5 30
```
###### Ví dụ 2.1 thêm vào ở vị trí bất kỳ
Nhưng đó là thêm ở đầu và cuối, nếu muốn thêm ở vị trí thử 2 3 4 thì mình có thể +1 lên cho vị trí thứ 2

Giả dụ như là
```cpp
/*
    1: 0x01 0x02 0x03 0x04 
    2:
    ...
    5: 0xa1 0xa2 0xa3 0xa4      0xa5
*/
```
Thì lúc này từ vị trí begin là vị trí đầu tiên của vector + 1 lên theo kiểu int là 4byte thì nó sẽ lên 0x05

```cpp
int main(int argc, char const *argv[])
{
    vector<int> vec;    // khai báo vector rỗng
    vec.push_back(1);   // 1
    vec.push_back(2);   // 1 2
    vec.push_back(3);   // 1 2 3 
    vec.push_back(4);   // 1 2 3 4 
    vec.push_back(5);   // 1 2 3 4 5

    // vec.insert(0, 10);  // lỗi no matching
    vec.insert(vec.begin(), 10);        // push_front()
    vec.insert(vec.end(), 30);      // push_back()
    vec.insert(vec.begin() + 1, 15);  
    vec.insert(vec.end() - 1, 40);       

    for(int i= 0; i<vec.size(); i++)
    {
        cout << vec[i] << " ";   // or vec.at(i)
    }

    return 0;
}
```

Kết quả
```cpp
10 15 1 2 3 4 5 40 30
```
##### Ví dụ 3: hàm pop_back() và erase()
Tương tự với 2 hàm push_back() và insert()
```cpp
int main(int argc, char const *argv[])
{
    vector<int> vec;    // khai báo vector rỗng
    vec.push_back(1);   // 1
    vec.push_back(2);   // 1 2
    vec.push_back(3);   // 1 2 3 
    vec.push_back(4);   // 1 2 3 4 
    vec.push_back(5);   // 1 2 3 4 5

    // vec.insert(0, 10);  // lỗi no matching
    vec.insert(vec.begin(), 10);        // push_front()
    vec.insert(vec.end(), 30);      // push_back()
    vec.insert(vec.begin() + 1, 15);  
    vec.insert(vec.end() - 1, 40);     
    // vector lúc này  10 15 1 2 3 4 5 40 30 

    vec.pop_back();
    vec.erase (vec.begin() + 2);

    for(int i= 0; i<vec.size(); i++)
    {
        cout << vec[i] << " ";   // or vec.at(i)
    }

    return 0;
}
```
Kết quả
```cpp
10 15 2 3 4 5 40
```
###### Ví dụ 3.1: xóa nhiều phần tử
Ngoài ra erase nngoaif việc xóa tại 1 vị trí bất kì thì nó còn giúp xóa nhiều phần tử cùng 1 lúc

Nhưng để làm được điều này thì trước đó phải quy định phạm vi trước khi xóa

```cpp
int main(int argc, char const *argv[])
{
    vector<int> vec;    // khai báo vector rỗng
    vec.push_back(1);   // 1
    vec.push_back(2);   // 1 2
    vec.push_back(3);   // 1 2 3 
    vec.push_back(4);   // 1 2 3 4 
    vec.push_back(5);   // 1 2 3 4 5

    // vec.insert(0, 10);  // lỗi no matching
    vec.insert(vec.begin(), 10);        // push_front()
    vec.insert(vec.end(), 30);      // push_back()
    vec.insert(vec.begin() + 1, 15);  
    vec.insert(vec.end() - 1, 40);     
    // 10 15 1 2 3 4 5 40 30 

    // vec.pop_back();
    // vec.erase (vec.begin() + 2);
    vec.erase(vec.begin(), vec.begin() + 3);

    for(int i= 0; i<vec.size(); i++)
    {
        cout << vec[i] << " ";   // or vec.at(i)
    }

    return 0;
}
```
Kết quả
```cpp
2 3 4 5 40 30
```
***
## Phần 2: Double Linked List
***
### 2.1. Khái niệm
***
List là một container trong STL của C++, triển khai dưới dạng danh sách liên kết hai chiều.

Một số đặc điểm quan trọng của list:
- Truy cập tuần tự: Truy cập các phần tử của list chỉ có thể thực hiện tuần tự, không hỗ trợ truy cập ngẫu nhiên.
- Hiệu suất chèn và xóa: Chèn và xóa ở bất kỳ vị trí nào trong danh sách có hiệu suất tốt hơn so với vector. Điều này đặc biệt đúng khi thêm/xóa ở giữa danh sách.

![Image](https://github.com/user-attachments/assets/4389662f-d3e6-4aad-8269-6061a4b0f6ba)

Single Linked List: duyệt 1 chiều (từ node đầu → node cuối)

Doubly Linked List: 
- duyệt xuôi: từ node đầu → node cuối: con trỏ next
- duyệt ngược: từ node cuối → node đầu: con trỏ prev
***
### 2.2. Ứng dụng
***
Trong thực tế, khi viết thư viện thì người ta thường chọn danh sách liên két đôi hơn là danh sách liên kết đơn vì

Ưu điểm: có thể duyệt ngược lẫn duyệt xuôi, linh hoạt hơn danh sách liên kết đơn
***
### 2.3. Một số method của list
***
Một số method của list:
- push_back(): thêm node cuối list
- push_front(): thêm node đầu list
- insert(): thêm node vị trí bất kỳ
- pop_back(): xóa node cuối list
- pop_front(): xóa node đầu list
- erase(): xóa node bất kỳ của list
- size(): Trả về kích thước của list

#### 2.3.1. Khai báo list
***
Khai báo ở list giống với khai báo vector, bao gồm
- khai báo rỗng
- khai báo chỉ định số lượng (=0)
- khai báo chỉ định số lượng và giá trị
- khai báo giá trị

```cpp
#include <iostream>
#include <list>

using namespace std;

int main(int argc, char const *argv[])
{
    // list<int> lst = {1,3,5,7,8};       // node 0,1,2,3,4  // cách 1
    // list<vector<int>> lst = {1,3,5,7,8};       // node 0,1,2,3,4
    // list<int> lst1(5);       // cách 2
    // list<int> lst2(5,2);     // cách 3

    list<int> lst;
}
```

Đối với cách khai báo danh sách rỗng thì để thêm vào thì phải sử dụng những method như push_back() và push_front() 

```cpp
    lst.push_back(1);       // node 0   0x01
    lst.push_back(4);       // node 0   0x01
    lst.push_back(3);       // node 0   0x01
    lst.push_back(2);       // node 0   0x01
    lst.push_back(15);       // node 0   0x01

    lst.push_front(100);

    lst.pop_back();
    lst.pop_front();
```

#### 2.3.2. duyệt list
***
Đối với duyệt list thì giống với vector nhưng sẽ có các cách như sau:
- Cách 1: là dùng for cải tiến (range base for loop)
- Cách 2: là dùng iterator (bộ lặp)
- Còn dùng vòng lặp for thông thường để duyệt qua từng node thì ở đây list không dùng được vì danh sách liên kết đôi có cơ chế duyệt xuôi duyệt ngược nên 1 vòng lặp for là không đáng kể

##### Ví dụ 1: Duyệt list dùng for cải tiến (mặc định duyệt xuôi)
```cpp
int main(int argc, char const *argv[])
{
    list<int> lst = {1,3,5,7,8};       // node 0,1,2,3,4

    lst.push_back(1);       // node 0   0x01
    lst.push_back(4);       // node 1   0x12
    lst.push_back(3);       // node 2   0x25
    lst.push_back(2);       // node 3   0xaa
    lst.push_back(15);       // node 4   0xb4

    lst.push_front(100);

    // Cách 1: for cải tiến
    int i = 0;
    for(auto item : lst)    // range base for loop
    {
        cout << "node: " << i++  << ", value: "<< item << endl;
    }
    return 0;
}
```
ở đây thì item không phải là 1 vị trí nữa mà là giá trị của node tại đó, còn i thì tương ứng với giá tri của từng node được duyệt qua

nên khi in ra thì mình in chính giá trị item đó 

Kết quả
```cpp
node: 0, value: 100
node: 1, value: 1
node: 2, value: 3
node: 3, value: 5
node: 4, value: 7
node: 5, value: 8
node: 6, value: 1
node: 7, value: 4
node: 8, value: 3
node: 9, value: 2
node: 10, value: 15
```
##### Ví dụ 2: duyệt list dùng for iterator (duyệt xuôi)
Cũng tương tự với vector thì ở list cũng có các hàm begin và end sử dụng cho iterator để tương ứng sử dụng cho list
-	begin(): địa chỉ của node đầu tiên		// 0x01
-	end(): địa chỉ sau node cuối cùng		// 0xa1

đối với list thì hơi khác 1 chút 
-	begin giống với vector
-	nhưng mà end thì không đoán trước được vì các node không liền kề với nhau

```cpp
int main(int argc, char const *argv[])
{
    list<int> lst = {1,3,5,7,8};       // node 0,1,2,3,4
    // list<int> lst;

    // lst.resize(7);

    lst.push_back(1);       // node 0   0x01
    lst.push_back(4);       // node 0   0x01
    lst.push_back(3);       // node 0   0x01
    lst.push_back(2);       // node 0   0x01
    lst.push_back(15);       // node 0   0x01

    lst.push_front(100);

    // Cách 1: for cải tiến
    int i = 0;
    for(auto item : lst)    // range base for loop
    {
        cout << "node: " << i++  << ", value: "<< item << endl;
    }

    cout<<endl;

    // cách 2: for iterator
    list<int>::iterator it;
    for(it = lst.begin(); it != lst.end(); it++)
    {
        cout << *it << " ";
    }

    return 0;
}
```
it++ như ở vector khi dùng iterator là it + 1 (1 * sizeof(int))

còn ở list thì it++ bây h là trỏ đến địa chỉ của node tiếp theo (dùng con trỏ next để đọc giá trị địa chỉ của node tiếp theo)

Kết quả
```cpp
node: 0, value: 100
node: 1, value: 1
node: 2, value: 3
node: 3, value: 5
node: 4, value: 7
node: 5, value: 8
node: 6, value: 1
node: 7, value: 4
node: 8, value: 3
node: 9, value: 2
node: 10, value: 15

100 1 3 5 7 8 1 4 3 2 15
```
##### Ví dụ 3: duyệt list dùng for iterator (duyệt ngược)
```cpp
int main(int argc, char const *argv[])
{
    list<int> lst = {1,3,5,7,8};       // node 0,1,2,3,4
    // list<int> lst;
    // list<int> lst1(5);
    // list<int> lst2(5,2);

    // lst.resize(7);

    lst.push_back(1);       // node 0   0x01
    lst.push_back(4);       // node 0   0x01
    lst.push_back(3);       // node 0   0x01
    lst.push_back(2);       // node 0   0x01
    lst.push_back(15);       // node 0   0x01

    lst.push_front(100);

    // Cách 1: for cải tiến
    int i = 0;
    for(auto item : lst)    // range base for loop
    {
        cout << "node: " << i++  << ", value: "<< item << endl;
    }

    cout<<endl;

    // cách 2: for iterator  
    cout << "duyet xuoi: ";
    list<int>::iterator it;
    // (duyệt xuôi)
    for(it = lst.begin(); it != lst.end(); it++)
    {
        cout << *it << " ";
    }

    cout << endl;
    // (duyệt ngược)
    cout <<"duyet nguoc: ";

    // for(it = lst.end(); it != lst.begin(); --it)
    // { 
    //     cout<< *it << " "; 
    // } 
    // => không hợp lệ (sai kết quả)

    it = lst.end();
    while (it != lst.begin())
    {
        --it;
        cout<< *it << " ";
    }
    return 0;
}
```
Kết quả
```cpp
node: 0, value: 100
node: 1, value: 1
node: 2, value: 3
node: 3, value: 5
node: 4, value: 7
node: 5, value: 8
node: 6, value: 1
node: 7, value: 4
node: 8, value: 3
node: 9, value: 2
node: 10, value: 15

duyet xuoi: 100 1 3 5 7 8 1 4 3 2 15
duyet nguoc: 15 2 3 4 1 8 7 5 3 1 100
```

##### Ví dụ 4: thêm hoặc xóa node bất kỳ insert() và erase()

Đối với vector thì các phần tử sẽ xếp theo thứ tự liền kề còn list thì không nên không dùng +1 tức 1 * sizeof(<kiểu dữ liệu>) được

Cũng dùng iterator
```cpp
int main(int argc, char const *argv[])
{
    list<int> lst = {1,3,5,7,8};       // node 0,1,2,3,4

    lst.push_back(1);       // node 0   0x01
    lst.push_back(4);       // node 0   0x01
    lst.push_back(3);       // node 0   0x01
    lst.push_back(2);       // node 0   0x01
    lst.push_back(15);       // node 0   0x01

    lst.push_front(100);

    // cách 2: for iterator  
    cout << "duyet xuoi: ";
    list<int>::iterator it;
    // (duyệt xuôi)
    for(it = lst.begin(); it != lst.end(); it++)
    {
        cout << *it << " ";
    }

    cout << endl;

    cout<< "Insert - Erase: ";
    // list<int>::iterator it;
    int i = 0;
    for(it = lst.begin(); it != lst.end(); it++)
    {
        // Thêm node vào vị trí thứ 2
        if(i == 2)
        {
            lst.insert(it, 765);
        }

        // xóa node ở vị trí thứ 4
        if(i == 4)
        {
            it = lst.erase(it);   // cập nhật lại it để tiếp tục duyệt
        }

        i++;
    }

    for(it = lst.begin(); it != lst.end(); it++)
    {
        cout << *it << " ";
    }
    return 0;
}
```
Kết quả
```cpp
duyet xuoi: 100 1 3 5 7 8 1 4 3 2 15 
Insert - Erase: 100 1 765 3 5 7 8 1 4 3 2 15
```
***
## Phần 3: Iterator
***
Iterator cung cấp một cách chung để duyệt qua các phần tử của một container mà không cần biết chi tiết về cách container được triển khai.

it là một đối tượng của class Iterator và nó được lồng vào trong class list hoặc vector cho phép truy cập tuần tự qua các phần tử của một container.

Nên những toán tử sử dụng như != hay == hay ++ hay dải tham chiếu nó sẽ không có mặc định cho it mà bên trong class phải được định nghĩa lại, mục đích sử dụng cho object it

Nó giống như con trỏ (không phải con trỏ, nó chỉ chứa 1 con trỏ bên trong thôi), cho phép di chuyển qua các phần tử trong container.

```cpp
template <typename T>
class list
{
    class iterator
    {
        private:
            T *ptr;    // con trỏ thô (raw pointer)

        public:
           iterator operator ++ () const
           {

           }
           iterator operator != () const
           {

           }
           iterator operator * () 
           {
                return *ptr;
           }
           // ....
    };
};
```
***
## Phần 4: MAP
***
### 4.1. Khái niệm:
***
Map là một container trong STL của C++, cung cấp một cấu trúc dữ liệu ánh xạ key-value (tương tự JSON).

Mỗi phần tử trong std::map là một std::pair<const Key, T>:
- Key là hằng số (không thể thay đổi sau khi thêm vào map). Khác với JSON là buộc là chuỗi
- T là kiểu dữ liệu của giá trị (value).

Map được phát triển dựa trên pair và template

### 4.2. Đặc điểm chính
***
| Đặc điểm | Miêu tả |
| --- | ---| 
| **Sắp xếp theo key**	| Các phần tử được tự động sắp xếp theo thứ tự tăng dần theo key |
| **Không cho phép trùng key**	| Mỗi key chỉ xuất hiện một lần duy nhất. |
| **Key là hằng số** | Key không thể thay đổi sau khi được thêm vào map |

### 4.3.	Khai báo key value cho map
***
Đối với JSON ở bên C thì  cặp key và value được đi kèm với nhau nhưng mặc định key phải ở dạng chuỗi 

Còn ở C++ thì key là bất kỳ kiểu nào cx được

**Cú pháp khai báo** 
```cpp
// cách 1
Map< <kiểu dữ liệu cho key>, <kiểu dữ liệu cho value> > object_name;

// cách 2
Map< <kiểu dữ liệu cho key>, <kiểu dữ liệu cho value> > object_name =
{
    {“000”, 0},
    {“001”, 5}
};
```
#### Ví dụ 1: khai báo cách 1: dùng khi khai báo ban đầu là object rỗng
khi object rỗng thì ta chèn phần tử vào object
```cpp
#include <iostream>
#include <string>
#include <map>

using namespace std;

int main(int argc, char const *argv[])
{
    map<string, int> m;  
    m["001"] = 1;       // key-value 1
    m["002"] = 2;       // key value 2
    m["003"] = 3;       // key-value 3

    return 0;
}
```
#### Ví dụ 2: Khai báo cách 2
```cpp
int main(int argc, char const *argv[])
{
    map<string, int> m = 
    {
        {"000", 0},     // key-value 1
        {"001", 5}      // key value 2
    }; 
    m["001"] = 1;       // key-value 2
    m["002"] = 2;       // key value 3
    m["003"] = 3;       // key-value 4

    return 0;
}
```

### 4.4.  Duyệt phần tử trong map
***
#### Cách 1: dùng range based for loop (for cải tiến)
***
ở trong vector thì item thì nó sẽ chứa toàn bộ dữ liệu, còn trong list thì nó sẽ chứa giá trị của toàn bộ node. Tương tự như vậy trong map thì khi mỗi lần duyệt qua thì nó cũng sẽ chứa toàn bộ cặp key – value của cặp đó luôn, 

Để lấy ra từng phần thì thư viện đã cung cấp 2 thành phần là first và second

##### Ví dụ 1: ghi đè phần tử + duyệt phần tử
```cpp
int main(int argc, char const *argv[])
{
    map<string, int> m = 
    {
        {"000", 0},     // key-value 1
        {"001", 5}      // key value 2
    }; 
    m["001"] = 1;       // key-value 1
    m["002"] = 2;       // key value 2
    m["003"] = 3;       // key-value 3

    // cách 1: range - based for loop
    for(const auto& item: m)
    {
        cout << "key: " << item.first << " - value: " << item.second << endl;
    }
    return 0;
}
```

Kết quả
```cpp
key: 000 - value: 0
key: 001 - value: 1
key: 002 - value: 2
key: 003 - value: 3
```

Như kết quả ở trên thì thầy cặp key value của "001" chỉ xuất hiện 1 lần vì cú pháp (m["001"] = 1; ) đã ghi đè lên giá trị của phần tử "001" trước đó

##### Ví dụ 2: thay đổi thứ tự khai báo của từng phần tử
Giả sử khai báo key 005  001  004  003 thì như thế nào
```cpp
int main(int argc, char const *argv[])
{
    map<string, int> m = 
    {
        {"005", 0},     // key-value 1
        {"001", 5}      // key value 2
    }; 

    m["001"] = 1;       // key-value 1
    m["004"] = 2;       // key value 2
    m["003"] = 3;       // key-value 3

    // cách 1: range - based for loop
    for(const auto& item: m)
    {
        cout << "key: " << item.first << " - value: " << item.second << endl;
    }
    return 0;
}
```
Kết quả
```cpp
key: 001 - value: 1
key: 003 - value: 3
key: 004 - value: 2
key: 005 - value: 0
```

Không in ra theo thứ tự cặp key – value được khai báo main

Nó đã tự động sắp xếp lại các key value tương ứng với giá trị thứ tự tăng dần của key (nếu là chuỗi thì cũng vậy nó sẽ so sánh theo mã ASCII của từng kí tự)

####  Cách 2: range based for loop 2 phần tử
***
Cách 1 là dùng 1 biến để lưu trữ key và value

Cách này dùng 2 biến lưu trữ riêng biệt

```cpp
int main(int argc, char const *argv[])
{
    // map<string, int> m;     // key: string hoặc others (int, char,..), value: int

    map<string, int> m = 
    {
        {"005", 0},     // key-value 1
        {"001", 5}      // key value 2
    }; 

    m["001"] = 1;       // key-value 1
    m["004"] = 2;       // key value 2
    m["003"] = 3;       // key-value 3
    
    // cách 2: range - based for loop
    for (const auto& [k,v] : m)     // k: key, v: value
    {
        cout << "key: " << k << " - value: " << v << endl;
    }
    return 0;
}
```
Kết quả: dùng cách 1 hay 2 đều cho ra két quả giống nhau
```cpp
key: 001 - value: 1
key: 003 - value: 3
key: 004 - value: 2
key: 005 - value: 0
```
#### Cách 3: Dùng lặp iterator
***
```cpp
int main(int argc, char const *argv[])
{
    map<string, int> m = 
    {
        {"005", 0},     // key-value 1
        {"001", 5}      // key value 2
    }; 

    m["001"] = 1;       // key-value 1
    m["004"] = 2;       // key value 2
    m["003"] = 3;       // key-value 3

    // cách 3: iterator
    map<string, int>::iterator it;      // khai báo object
    for(it = m.begin(); it != m.end(); it++)
    {
        cout << "key: " << (*it).first << " - value: " << (*it).second << endl;
    }

    return 0;
}
```
Kết quả: dùng cách 1,2 hay 3 đều cho ra két quả giống nhau
```cpp
key: 001 - value: 1
key: 003 - value: 3
key: 004 - value: 2
key: 005 - value: 0
```

### 4.5. Các method trong MAP
***
![Image](https://github.com/user-attachments/assets/04207587-fb3b-49a8-8620-5505a9eb8631)

#### 4.5.1. thêm hoặc xóa 1 cặp key - value vào map
***
Trong vector và list thì cung cấp các hàm như push và pop nhưng map thì không những vẫn còn insert và erase

Khi dùng insert hay erase thì không cần phải truyền vào địa chỉ như list vì khi thêm vào thì map cx sắp xếp lại theo thứ tự của key

Chỉ cần đảm bảo là key không trùng với cặp key value ở trước

```cpp
int main(int argc, char const *argv[])
{
    map<string, int> m = 
    {
        {"005", 0},     // key-value 1
        {"001", 5}      // key value 2
    }; 

    m["001"] = 1;       // key-value 1
    m["004"] = 2;       // key value 2
    m["003"] = 3;       // key-value 3
    m.at("003") = 10;

    m.insert({"006", 12});
    m.erase("001");


    map<string, int>::iterator it;      // khai báo object
    it = m.find("004");
    if(it!= m.end())
    {
        (*it).second = 50;
    }

    // cách 3: iterator
    // map<string, int>::iterator it;      // khai báo object
    for(it = m.begin(); it != m.end(); it++)
    {
        cout << "key: " << (*it).first << " - value: " << (*it).second << endl;
    }

    return 0;
}
```
Kết quả thêm 006 và xóa 001
```cpp
key: 003 - value: 10
key: 004 - value: 50
key: 005 - value: 0
key: 006 - value: 12
```

### 4.6.	Ứng dụng của map
***
Map thường được dùng để lưu trữ dữ liệu vì nó hoạt động dưới key value

Và nó cũng sẽ được dùng để sắp xếp, tìm kiếm dữ liệu (không cần dùng các thuật toán sort vì map đã tự sắp xếp, chỉ cần dùng thuật toán tìm kiếm)

***
## Phần 5: Lambda
***
### 5.1. Khái niệm
***
- Lambda là 1 hàm nhưng sẽ thường được sử dụng 1 lần duy nhất trong chương trình (nhưng vẫn có thể tái sử dụng)
- Là 1 hàm không có tên, vẫn có tham số, kiểu trả về,…
- Lambda được định nghĩa tại chỗ khi khai báo (toàn cục hoặc cục bộ)
- Cách sử dụng của nó

### 5.2. Cú pháp
***
Cú pháp của lambda có 2 phiên bản
Phiên bản 1:
```cpp
[capture] [parameter_list]  return_type
{
     // function body
};
```

Phiên bản 2: trình biên dịch tự dự đoán kiểu trả về
```cpp
[capture] [parameter_list]
{
     // function body
};
```
#### 5.2.1. return_type
Lambda thì thường được sử dụng trong hàm cục bộ
```cpp

// // khai báo lambda - hàm toàn cục
// []() -> void
// {
//     cout<< "Hello World\n";
// };

int main(int argc, char const *argv[])
{
    // khai báo lambda - hàm cục bộ
    []() -> void
    {
        cout<< "Hello World\n";
    };
    return 0;
}
```
=> chỉ khai báo chứ chưa sử dụng được

#### 5.2.2. Cách sử dụng
có 2 cách sử dụng:
##### Cách 1: sử dụng toán tử ()
- Để gọi ra ngay khi mình bảo, tức dấu ;
- Cách này sử dụng khi muốn sử dụng 1 lần duy nhất

Ví dụ:
```cpp
#include <iostream>

using namespace std;

// // khai báo lambda - hàm toàn cục
// []() -> void
// {
//     cout<< "Hello World\n";
// };

int main(int argc, char const *argv[])
{
    // khai báo lambda - hàm cục bộ
    []() -> void
    {
        cout<< "Hello World\n";
    }();
    return 0;
}
```
Kết quả
```cpp
Hello World
```
##### Cách 2: lưu trữ trong 1 biến
-	Tương tự với việc sử dụng 1 con trỏ hàm nhưng đơn giản hơn 
-	Có thể sử dụng lại nhiều lần, nhưng chỉ trong phạm vi cho phép 

Ví dụ:
```cpp
int main(int argc, char const *argv[])
{
    // khai báo lambda - hàm cục bộ
    []() -> void
    {
        cout<< "1- Hello World 1\n";
    }();

    // cách 2
    auto func = []()            
    {
        cout<< "2- Hello World 2\n";
    };

    func();

    return 0;
}
```
Hiện tại Chỉ sử dụng trong phạm vi main thôi, để ngoài main là lỗi

Kết quả
```cpp
1- Hello World 1
2- Hello World 2
```
#### 5.2.3. Thành phần parameter_list
truyền tham số vào để sử dụng
```cpp
int main(int argc, char const *argv[])
{
    // khai báo lambda - hàm cục bộ
    []() -> void
    {
        cout<< "1- Hello World 1\n";
    }();

    // cách 2
    auto func = [](int x, double y)            
    {
        cout<< "2- Hello World 2\n";
        cout << "x = " << x << "- y = " << y <<endl; 
    };

    func(2, 5.6);
    func(3, 3.14);

    return 0;
}
```
Kết quả
```cpp
1- Hello World 1
2- Hello World 2
x = 2- y = 5.6
2- Hello World 2
x = 3- y = 3.14
```
#### 5.2.4. Thành phần capture
Capture cho biết cách sử dụng các biến xung quanh lambda

Khi khai báo a b c trong main thì đối với main thì a b c là biến cục bộ, nhưng còn đối với các hàm lambda thì a b c là biến toàn cục nhưng vẫn nằm trong phạm vi trong main.

Tuy nhiên không phải muốn sử dụng là sử dụng. mà phải quy định cách sử dụng:
-	Quy định giá trị của a b c   ví dụ như read only
-	Thay đổi giá trị a b c trong lambda

Có 1 số đặc điểm nhận dạng của capture như sau:
| cú pháp capture | đặc điểm |
| ---- | ---- |
| **[]** | capture rỗng -> không được sử dụng bất kì biến nào xung quanh |
| **[var]** | capture truyền giá trị -> chỉ sử dụng giá trị a, không thay đổi giá trị  (READ ONLY) |
| **[&var]** |	capture tham chiếu -> tác động địa chỉ của biến để thay đổi giá trị hoặc là đọc giá trị |
| **[&var1, var2] or others**	| var1: tham chiếu, var2: giá trị |
| **[=]**	|truyền tất cả biến theo giá trị (read only cho all biến) |
| **[&]**	| truyền tất cả biens theo địa chỉ (read - write) |

Ví dụ 
```cpp
int main(int argc, char const *argv[])
{
    int a = 0;
    int b = 1;
    double c = 5.7;

    // khai báo lambda - hàm cục bộ
    [a, &b]() -> void
    {
        cout<< "1- Hello World 1\n";
        
        cout << "a = " <<a << endl;
        b = 15;
        cout << "b = " << b <<endl; 
    }();
    return 0;
}
```
Kết quả
```cpp
1- Hello World 1
a = 0
b = 15
```
- Bây h đối với biến a là chỉ có Read only
- Biến b là vừa đọc vừa ghi
- Biến c là không sử dụng được trong lambda

***
## Phần 6: Algorithm
***
### 6.1. Khái niệm
***
Thư viện STL (Standard Template Library) cung cấp một số thuật toán tiêu biểu thông qua algorithm. Các thuật toán này hoạt động trên các phạm vi hoặc các loại dữ liệu khác nhau, giúp thực hiện các nhiệm vụ như sắp xếp (sort), tìm kiếm (find), chuyển đổi dữ liệu, count_if() , và nhiều thao tác khác. 

#### 6.2. Các hàm thông dụng
***
##### 6.2.1. Hàm sort()
###### a)	Ví dụ 1: Hàm sort() 2 tham số
- Hàm sort nhận 2 tham số truyền vào là 1 địa chỉ
- Mặc định là sắp xếp tăng dần

Ví dụ
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(int argc, char const *argv[])
{
    vector<int> v = {1,3,5,7,9,2,0,6,8,4};

    sort(v.begin(), v.end());       // mắc định sắp xếp theo tăng dần

    for(const auto& item : v)
    {
        cout<< item <<" ";
    }
    return 0;
}
```
Kết quả
```cpp
0 1 2 3 4 5 6 7 8 9
```
###### b)	Ví dụ 2: Hàm sort() 3 tham số
- Nâng cấp của hàm sort 2 tham số và có thêm 1 tham số truyền vào khác là điều kiện
- Có thể điều chỉnh tăng dần hoặc giảm dần tùy theo điều kiện

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

bool comp(int i, int j)
{
    return i>j;
}

int main(int argc, char const *argv[])
{
    vector<int> v = {1,3,5,7,9,2,0,6,8,4};

    // sort(v.begin(), v.end());       // mắc định sắp xếp theo tăng dần
    sort(v.begin(), v.end(), comp);       

    for(const auto& item : v)
    {
        cout<< item <<" ";
    }
    return 0;
}
```
Kết quả
```cpp
9 8 7 6 5 4 3 2 1 0
```
###### c)	Ví dụ 3: nâng cấp ví dụ 2
Với ví dụ 2 thì hàm comp đó chỉ có sử dụng duy nhất cho hàm sort thôi, mà cũng đang dùng toàn cục nữa sinh ra phí RAM quá => nên ở đây ta có thể sử dụng 1 hàm lambda ở đây để thay thế cách viết như hàm toàn cục
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(int argc, char const *argv[])
{
    vector<int> v = {1,3,5,7,9,2,0,6,8,4};
     
    sort(v.begin(), v.end(), [](int i, int j)
    {
        return i > j;    // giảm dần , tăng dần thì < (ngược lại)
    }); 

    for(const auto& item : v)
    {
        cout<< item <<" ";
    }
    return 0;
}
```
Kết quả
```cpp
9 8 7 6 5 4 3 2 1 0
```
#### 6.2.2.	Hàm count_if()

Đếm số lượng dựa vào điều kiện nào đó

Hàm này cũng giống với hàm sort(), 2 tham số đầu là địa chỉ bắt đầu và địa chỉ kết thúc, tham số thứ 3 là điều kiện

Ví dụ:
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(int argc, char const *argv[])
{
    vector<int> v = {1,3,5,7,9,2,0,6,8,4};
    
    int count_even = 0;
    int count_odd = 0;
    vector<int> evens, odds;

    count_if(v.begin(), v.end(), [&](int x)
    {
        if(x % 2 == 0)
        {
            count_even++;
            evens.push_back(x);
        }
        else
        {
            count_odd++;
            odds.push_back(x);
        }
        return false;
    }); 

    cout << "Number of evens: " << count_even << endl;
    cout << "Number of odds: " << count_odd << endl;

    for(const auto& item : evens)
    {
        cout<< item <<" ";
    }
    cout<<endl;
    for(const auto& item : odds)
    {
        cout<< item <<" ";
    }
    return 0;

```
Kết quả
```cpp
Number of evens: 5
Number of odds: 5
2 0 6 8 4
1 3 5 7 9
```

std::count_if() có nhiệm vụ duyệt từng phần tử của vector v.
- Nó chỉ đếm những phần tử mà lambda trả về true.
- Nhưng ở đây không cần dùng kết quả của count_if().
- Chỉ muốn tận dụng việc nó duyệt qua các phần tử, nên trả về false để count_if() không đếm gì cả (vì  đã đếm thủ công bằng count_even và count_odd rồi).

***
## Phần 7: Functor
***
### Đặt vấn đề
***
có đoạn code như sau:
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

auto pred1 = [](const int &x) { return x+1;};

auto pred2 = [](const int &x) { return x+2;};

int main()
{
    vector<int> v = {1, 2, 3, 4, 5};
   
    transform(v.begin(), v.end(), v.begin(), pred1);
   
    transform(v.begin(), v.end(), v.begin(), pred2);
   
    return 0;
}
```
Đối với ví dụ trên thì có định nghĩa 2 lambda khác nhau, và có 2 vector khác nhau. 
khi sử dụng hàm transform (): giúp tăng/giảm giá trị lên 1 đơn vị trong 1 mảng vector hay 1 mảng hoặc list
=> khi mà giá trị tăng lên 1 hoặc 2 đơn vị thì giá trị bị thay đổi nhưng nếu muốn tăng giá trị nhiều hơn thì buộc phải tạo thêm lambda và vector khác để phục vụ cho vấn đề này 
=> Liệu có cách nào để chỉ có 1 hàm duy nhât thôi để tăng 1 số lượng nhất định mà không cần phải khai báo lại vector và lambda
=> Sử dụng Functor

### 7.1. Khái niệm Functor
***
Functor (Function Object) là một đối tượng (object) có thể hoạt động như một hàm, tức là một class/struct mà bạn định nghĩa toán tử operator ().

#### 7.1.1. Khai báo
***
```cpp
template <typename T1, typename T2>
class Test
{
    public:
        void operator ()(){}

        void operator ()(T1 x){}

        void operator ()(T1 x, T2 y){}
};
```
##### 7.1.1.1. Ví dụ: 
```cpp
#include <iostream>
using namespace std;

template <typename T1, typename T2>
class Test
{
    public:
        void operator ()(){cout << "Functor 1\n";}
        void operator ()(T1 x){ cout << "x = " << x << endl;}
        void operator ()(T1 x, T2 y){cout << "x = " << x << " y = " << 2 << endl;}
};

int main(int argc, char const *argv[])
{
    Test<int, int> test;
    test();
    test(2);
    test(5,2);
    return 0;
}
```
Kết quả
```cpp
Functor 1
x = 2
x = 5 y = 2
```

#### 7.1.2. Đặc điểm của Functor
***
Đặc điểm của Functor:
●	Là hàm thành viên có quyền truy cập là public.
●	Không phải là static method.(bởi vì khi nó là 1 hàm static thì nó có thể gọi trực tiếp từ class mà không cần phải thông qua những đối tượng, lúc này việc định nghĩa không có ý nghĩa)
●	Có khai báo operator ().

##### Ví dụ: 
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Increment
{
    private:
        int num;
       
    public:
        Increment(int &n) : num(n){}
        int operator () (const int vec_num) const
        {
            return num + vec_num;
        }
};

int main()
{
    vector<int> v = {1, 2, 3, 4, 5};
   
    for (const auto &item : v)
    {
        cout << item << " ";
    }
    cout << endl;
  
    int add = 0;
    while (1)
    {
        cout << "Input: ";
        cin >> add;
        transform(v.begin(), v.end(), v.begin(), Increment(add));
        for (const auto &item : v)
        {
            cout << item << " ";
        }
        cout << endl;
    }
    return 0;
}
```
Kết quả
```cpp
1 2 3 4 5 
Input: 2  (nhập vào)
3 4 5 6 7
Input: 4
7 8 9 10 11
Input: ...
...
```

ở đây đoạn code sau khi đã được sửa lại 
-	Tạo 1 class mới 
-	Khai báo 1 biến trong class (trong private): biến này là biến đếm
-	Khởi tạo constructor, truyền vào giá trị để cộng với phần tử trong mảng của đối tượng
-	Vì nó là 1 hàm trong class nên nó có thể lưu trữ những biến khác nhau

=> lúc này sẽ hạn chế việc sử dụng lambda mà sử dụng Functor 
=>	Input bằng bao nhiêu thì sẽ tăng giá trị của từng phần trử trong mảng lên ứng với giá trị của Input

### 7.2.	Sự khác nhau giữa Functor và Lambda
***
Sự khác nhau giữa Functor và Lambda/Global Function:

- Lưu trạng thái nội tại (internal state): Functor là object, nên có thể chứa biến thành viên, giúp lưu trạng thái giữa các lần gọi.
- Tùy biến hành vi qua constructor: có thể truyền tham số vào constructor để điều chỉnh cách operator () hoạt động.
- Dễ kết hợp với STL (Standard Template Library). Ví dụ: std::sort, std::find_if, std::for_each có thể dùng functor để thực hiện hành vi tùy biến.
- Dễ dàng kiểm thử.

#### 7.2.1. Ví dụ 1: quản lý sinh viên
```cpp

typedef struct
{
    string name;
    double gpa;
} Student;

// Functor để lọc sinh viên và lưu vào danh sách riêng
class GPAFilter
{
    private:
        double minGPA;
        vector<Student>& resultList;

    public:
        GPAFilter(double threshold, vector<Student>& output)
            : minGPA(threshold), resultList(output) {}
   
        bool operator()(const Student& s)
        {
            if (s.gpa > minGPA)
            {
                resultList.push_back(s);
            }
            return false;  // Để find_if tiếp tục
        }
};

int main()
{
    vector<Student> students =
    {
        {"Alice", 3.2},
        {"Bob", 2.8},
        {"Charlie", 3.9},
        {"David", 2.5}
    };
    double minGPA = 3.0;
    vector<Student> s1;
    // sử dụng functor
    GPAFilter filter(minGPA, s1);

    minGPA = 2.6;  // Không ảnh hưởng đến filter đã tạo
    
    find_if(students.begin(), students.end(), filter);

    for (const auto& item : s1)
    {
        cout << item.name << " ";
    }

    return 0;
}
```
Kết quả
```cpp
Alice Charlie
```
#### 7.2.2. Ví dụ 2: Kết hợp STL
```cpp
class Increasing
{
     public:
         bool operator () (int a, int b) const
         {
            return a < b;
         }
         // bool operator () (int a, int b) const
         // {
         //     return a > b;
         // }
};

class Printer
{
     public:
         void operator () (int x) const
         {
            cout << x << " ";
         }
};

int main()
{
     vector<int> v = {3, 1, 4, -2, -5, 12, 8, 24};

     sort(v.begin(), v.end(), Increasing());

     for_each(v.begin(), v.end(), Printer());

     return 0;
}
```
Kết quả:
```cpp
-5 -2 1 3 4 8 12 24
```
ở đây Không thể viết cả hai chức năng tăng dần và giảm dần vào trong cùng 1 class được mặc dù cấu trúc của nó khác nhau nhưng việc khai báo class chức thì nằm trong cùng 1 class khiển cho trình biên dịch không phân biệt được là chức năng nào nên phải tách ra

#### 7.2.3. Ví dụ 3: Dễ kiểm thử
sử dụng kết hợp thư viện assert để kiểm thử code
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <cassert>      // thư viện assert bên C
using namespace std;

typedef struct
{
    string name;
    double gpa;
} Student;

// Functor để lọc sinh viên và lưu vào danh sách riêng
class GPAFilter
{
    private:
        double minGPA;
        vector<Student>& resultList;

    public:
        GPAFilter(double threshold, vector<Student>& output)
            : minGPA(threshold), resultList(output) {}
   
        bool operator()(const Student& s)
        {
            if (s.gpa > minGPA)
            {
                resultList.push_back(s);
            }
            return false;  // Để find_if tiếp tục
        }
};

void test_GPAFilter_basic()
{
    vector<Student> input = 
    {
        {"Alice", 3.2}, {"Bob", 2.8}, {"Charlie", 3.9}, {"David", 2.5}
    };
    vector<Student> output;
    GPAFilter filter (3.0, output);
    for(const auto & s: input)
    {
        filter(s);      // test từng phần tử như find_if
    }
    assert(output.size() == 2);
    assert(output[0].name == "Alice");
    assert(output[1].name == "Charlie");
}

void test_GPAFilter_no_match()
{
    vector<Student> input = 
    {
        {"Bob", 2.8}, {"David", 2.5}
    };
    vector<Student> output;
    GPAFilter filter (3.0, output);
    for(const auto & s: input)
    {
        filter(s);      // test từng phần tử như find_if
    }
    assert(output.empty());
}

void test_GPAFilter_all_match()
{
    vector<Student> input = 
    {
        {"Alice", 3.2}, {"Charlie", 3.9}
    };
    vector<Student> output;
    GPAFilter filter (3.0, output);
    for(const auto & s: input)
    {
        filter(s);      // test từng phần tử như find_if
    }
    assert(output.size() == 3);
}

int main()
{
    test_GPAFilter_all_match();
    test_GPAFilter_basic();
    test_GPAFilter_no_match();
    cout << "All tests passed";

    return 0;
}
```
Kết quả
```cpp
Assertion failed: output.size() == 3, file EX5.cpp, line 79
```

### 7.3.	Trường hợp sử dụng Lmabda / Functor
***
Khi nào dùng Lambda/Functor?

Dùng Lambda khi:
- Logic ngắn gọn
- Thường dùng một lần duy nhất
- Cần sử dụng các biến xung quanh một cách nhanh chóng.

Dùng Functor khi:
- Logic phức tạp
- Tái sử dụng được nhiều nơi vì đã viết thành struct/class
- Cần lưu trữ trạng thái lâu dài.
- Cần mở rộng, kế thừa trong OOP (Ví dụ 2.1.3)
***